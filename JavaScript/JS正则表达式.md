# JS正则表达式 #
## 供查询 ##
|-|-|
|/g|查找所有可能的匹配，返回的结果可以是多个|
|/i|表示匹配的时候不区分大小写|
|/m|表示多行匹配，影响正则中的`^$`符号|
|/s|dotAll模式，使得`.`可以匹配任意单个字符|
|/u|Unicode模式，用来正确处理大于`\uFFFF`的Unicode字符|
|/y|与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始。|

|-|-|
|*|星号代表匹配它前面一个字符任意遍（0或任意次）|
|+|表示匹配前面字符一个或多次（至少一次）|
|?|问号代表匹配前一个字符0次或1次|
|[]|中括号用来表示一个字符集合，`^`在`[]`中表示匹配任何不在该集合中的字符|
|{}|大括号的作用是指重复前面一个字符多少遍，例{N}：重复n遍；{n,m}：重复n~m遍；{n, }：至少重复n遍；{,m}：最多重复m遍|

|-|-|
|\w|小写w表示字母或数字，等价于[a-zA-Z0-9]|
|\W|大写W表示非字母且数字，与\w相反，等价于[^a-zA-Z0-9]|
|\s|小写s表示匹配一个空字符，包括空格，换行，回车，tab，等价于[\n\r\t\f]|
|\S|大写S匹配非空格字符，与\s相反，等价于[^\n\r\t\f]|
|\d|小写d表示十进制数字，等价于[0-9]|
|\D|大写D匹配一个非数字字符，等价于[^0-9]|

## () [] {}的区别 ##

|-|-|
|()|()的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。比如(\s+)表示连续空格的字符串|
|[]|[]是定义匹配的字符范围。比如[a-zA-Z0-9]表示字符文本要匹配英文字符和数字|
|{}|{}一般用来表示匹配的长度，比如\d{3}表示匹配三个数字，\d{1,3}表示匹配1~3个数字，\d{3,}表示匹配3个以上数字|

## 关于空格 ##

|-|-|
|\s|空格|
|\uFEFF|ES5新增的空白符，叫`字节次序标记字符（Byte Order Mark）`，也就是BOM|
|\xA0|禁止自动换行空白符，相当于html中的`&nbsp;`|
|"","\x20","\u0020"|半角空格符，键盘空格键|
|"\t","\x09","\u0009"|制表符，键盘tab键|
|"\v","\x0B","\u000B"|垂直制表符|
|"\f","\x0C","\u000C"|换页符|
|"\r","\x0D","\u000D"|回车符|
|"\n","\x0A","\u000A"|换行符|

对于IE低版本，`\s`等价于`[\t\v\f\r\n]`

例子：

trim的polyfill

	if(!String.prototype.trim) {
		String.prototype.trim = function() {
			return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,'');
		};
	}
解析：

- `[]`表示范围
- `^`表示行的开头，`$`表示行的结束
- `+`代表前面的字符必须至少出现一次（1次或多次）

## 创建一个正则表达式 ##
> 字面量：`var expression = / pattern / flags;`

> RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。

要注意的是：传递给RegExp构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp构造函数）。由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义。

其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。

模式中使用的所有**元字符**都必须转义。正则表达式中的元字符包括：

	( [ { \ ^ $ | ) ? * + . ] }

## 属性 ##
- flags：返回正则表达式的修饰符。
- sticky：表示是否设置了y修饰符。
- unicode：表示是否设置了u修饰符。
- global：布尔值，表示是否设置了g修饰符。
- ignoreCase：布尔值，表示是否设置了i标志。
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。
- multiline：布尔值，表示是否设置了m标志。
- source：正则表达式的字符串表示。

## RegExp实例方法 ##
### exec() ###
该方法是专门为捕获组而设计的。`exec()`接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。

返回的数组包含两个额外的属性：

- index：表示匹配项在字符串中的位置
- input：表示应用正则表达式的字符串

在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。

对于`exec()`方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用`exec()`将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用`exec()`则都会在字符串中继续查找新匹配项。

### test() ###
接收一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。

## 字符串的正则方法 ##
字符串对象共有4个方法，可以使用正则表达式：`match()`、`replace()`、`search()`和`split()`。

## 断言 ##
### 先行断言 ###
`x`只有在`y`前面才匹配，必须写成`/x(?=y)/`。

### 先行否定断言 ###
`x`只有不在`y`前面才匹配，必须写成`/x(?!y)/`。

### 后行断言 ###
`x`只有在`y`后面才匹配，必须写成`/(?<=y)x/`。

### 后行否定断言 ###
`x`只有不在`y`后面才匹配，必须写成`/(?<!y)x/`。

## 具名组匹配 ##
允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。

“具名组匹配”在圆括号内部，模式的头部天剑“问号+尖括号+组名”（`?<year>`)，然后就可以在`exec`方法返回结果的`groups`属性上引用该组名。

字符串替换时，使用`$<组名>`引用具名组。

	let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
	'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')
	// '02/01/2015'


参考:

- [https://www.jb51.net/article/96272.htm](https://www.jb51.net/article/96272.htm)
- [https://www.cnblogs.com/onepixel/p/5218904.html](https://www.cnblogs.com/onepixel/p/5218904.html)
