# HTTP #
HTTP协议解决文件传输的问题。HTTP是应用层协议。
HTTP是基于传输层TCP协议的，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。

HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。

> HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。

## 简单三次握手 ##
![](https://i.imgur.com/E18Hj9k.png)

![](https://i.imgur.com/3m5vEGl.png)

![](https://i.imgur.com/H08B9wh.png)
## HTTP请求 ##
所谓的HTTP请求，也就是Web客户端向Web服务器发送信息，这个信息由如下三部分组成：

1. 请求行：只有一行
2. HTTP头：可以有多行，每一行是一对键值对。 
	- 请求头（request header）
	- 普通头（general header）
	- 实体头（entity header）
3. 内容（只在POST请求中存在）

一个典型的请求行比如：

	GET www.baidu.com HTTP/1.1
方法、资源的路径、协议的版本、可选的请求首部字段和内容实体构成。

请求首部字段：

	Host: hackr.jp
	Connection: keep-alive
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 16

内容实体：

	name=ueno&age=37

## HTTP请求方法 ##
- GET：从指定的资源请求数据
- POST：向指定的资源提交要被处理的数据
- PUT：传输文件

	就像FTP协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。
- DELETE：删除文件

	是与PUT相反的方法。DELETE方法按请求URI删除指定的资源。
- HEAD：请求响应报文首部

	和GET一样，但不返回报文主体。用于确认URI的有效性及资源更新的日期时间等。
- OPTIONS：返回请求的资源所支持的方法的方法
- CONNECT：要求用隧道协议连接代理

	CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。

	格式：
		
		CONNECT 代理服务器名:端口号 HTTP版本
- TRACE：追踪路径

	TRACE方法是让Web服务器端将之前通信环回给客户端的方法。

	发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止继续传输，最后接收到请求的服务端则返回状态码200 OK的响应。

	客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。

	TRACE方法容易引发XST（Cross-Site Tracing，跨站追踪）攻击。


方法名区分大小写，注意要用大写字母。

![](https://i.imgur.com/65JlR5I.png)
### 比较GET与POST ###
GET方法：

- 查询字符串（名称/值对）是在GET请求的URL中发送的。
- GET请求可被缓存
- GET请求保留在浏览器历史记录中
- GET请求可被收藏为书签
- GET请求不应在处理敏感数据时使用
- GET请求只应当于取回数据

POST方法：

- 查询字符串（名称/值对）是在POST请求的HTTP消息主体中发送的。
- POST请求不会被缓存
- POST请求不会保留在浏览器历史记录中
- POST不能被收藏为书签
- POST请求对数据长度没有要求

![](https://i.imgur.com/t2MQWbq.png)

参考文章：

- [GET和POST两种基本请求方法的区别](https://www.cnblogs.com/logsharing/p/8448446.html)

## 指定请求URI ##
### 方法一 URI为完整的请求URI ###
	GET http://hackr.jp/index.htm HTTP/1.1
### 方法二 在首部字段Host中写明网络域名或IP地址 ###
	GET /index.htm HTTP/1.1
	Host: hackr.jp
### 其他 ###
除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个`*`来代替请求URI。

例子：查询HTTP服务器端支持的HTTP方法种类

	OPTIONS * HTTP/1.1
## HTTP响应 ##
1. 状态行
2. HTTP头
	- 请响应头（response header）
	- 普通头（general header）
	- 实体头（entity header）
3. 返回内容

一个典型的HTTP状态如下：

	HTTP/1.1 200 OK
第一部分是HTTP版本，第二部分是响应状态码，第三部分是状态码的描述（原因短语）。

	HTTP/1.1 200 OK
	Date: Tue, 10 Jul 2012 06:50:15 GMT	
	Content-Length: 362
	Content-Type: text/html

	<html>
	...

显示了创建响应的日期时间，是首部字段内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体

> 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

## HTTP状态码分类 ##
- 信息类（100-199）
- 响应成功（200-299）
- 重定向类（300-399）
- 客户端错误类（400-499）
- 服务端错误类（500-599）


----------
当我们在浏览器的地址栏输入www.linux178.com，然后回车，回车这一瞬间到看到页面到底发生了什么呢？

域名解析 --> 发去TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

### 域名解析 ###
1. 搜索浏览器自身的DNS缓存[chrome://net-internals/#dns](chrome://net-internals/#dns)
2. 操作系统自身的DNS缓存 `ipconfig /displaydns`
3. 尝试读取hosts文件（位于C:\windows\System32\drivers\etc)
4. 向本地配置的首选DNS服务器发起域名解析请求。。。

参考文章：

- [一次完整的HTTP事务是怎样一个过程？](http://blog.51cto.com/linux5588/1351007)

## 持久连接 ##
持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。持久连接旨在建立1次TCP连接后进行多次请求和响应的交互。

持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

在HTTP/1.1中，所有的连接默认都是持久连接，但在HTTP/1.0内并未标准化。

## 管线化 ##
不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。

## HTTP报文 ##
用于HTTP协议交互的信息被称为HTTP报文。HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。

HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

报文首部：服务器端或客户端需处理的请求或响应的内容及属性。

![](https://i.imgur.com/y2qliqT.png)

![](https://i.imgur.com/1DDjQF0.png)

- 请求行：包含用于请求的方法，请求URI和HTTP版本。
- 状态行：包含表明响应结果的状态码，原因短语和HTTP版本。
- 首部字段：包含表示请求和响应的各种条件和属性的各类首部。
	- 通用首部
	- 请求首部
	- 响应首部
	- 实体首部
- 其他：可能包含HTTP的RFC里未定义的首部（Cookie等）。

## 报文主体和实体主体 ##
- 报文：是网络中交换和传输的数据单元。即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息。
- 实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体主体组成。

![](https://i.imgur.com/vwVatz5.png)

我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容就是实体首部和实体主体。而左图中粉红色框内容就是报文主体。通常，**报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。**

## 内容编码 ##
内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

常用的内容编码有以下几种。

- gzip（GNU zip）
- compress（UNIX系统的标准压缩）
- deflate（zlib）
- identity（不进行编码）

## 分块传输编码 ##
分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。

## 多部分对象集合 ##
MIME：多用途因特网邮件扩展。允许邮件处理文本、图片、视频等多个不同类型的数据。MIME扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。

- multipart/form-data
- multipart/byteranges

在HTTP报文中使用多部分对象集合时，需要在首部字段里加上`Content-type`。使用`boundary`字符串来划分多部分对象集合指明的各类实体。在`boundary`字符串指定的各个实体的起始行之前插入`--`标记（例如：`--AaB03x`、`--THIS_STRING_SEPARATES`），而在多部分对象集合对应的字符串的最后插入`--`标记。

## 内容协商 ##
内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。   
包含在请求报文中的某些首部字段就是判断的基准。

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术有以下3种类型。

- 服务器驱动协商
- 客户端驱动协商
- 透明协商

## HTTP的缺点 ##
- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

### 通信的加密 ###
HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。  
用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。

### 查明对手的证书 ###
虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。

> 请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle-attack，MITM）

### 如何防止篡改 ###
虽然有是使用HTTP协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。

提供文件下载服务的Web网站也会提供相应的PGP（Pretty Good Privacy，完美隐私）创建的数字签名及MD5算法生成的散列值。PGP是用来证明创建文件的数字签名，MD5是由单向函数生成的散列值。用这些方法也依然无法百分百保证确认结果正确。因为PGP和MD5本身被改写的话，用户是没有办法意识到的。

为了防止这些弊端，有必要使用HTTPS。SSL提供认证和加密处理及摘要功能。仅靠HTTP确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。

## HTTP+加密+认证+完整性保护=HTTPS ##
HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。

在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

SSL采用一种叫做公开密钥加密的加密处理方式。公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

> 加密和解密同用一个密钥的方式称为共享密钥加密，也被叫做对称密钥加密

### HTTPS采用混合加密机制 ###
HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

### 数字证书认证机构的业务流程 ###
首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。

![](https://i.imgur.com/mn6TJqC.png)

## HTTPS的通信步骤 ##
1. 客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
2. 服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
3. 之后服务器发送Certificate报文。报文中包含公开密钥证书。
4. 最后服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。
5. SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。
6. 接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。
7. 客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
8. 服务器同样发送Change Cipher Spec报文。
9. 服务器同样发送Finished。
10. 服务器和客户端的Finished报文交换完毕之后，SSL连接就算建立成功。当然，通信会收到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求。
11. 应用层协议通信，即发送HTTP响应。
12. 最后由客户端断开连接。断开连接时，发送close_notify报文。这步之后再发送TCP FIN报文来关闭与TCP的通信。

在以上流程中，应用层发送数据时会附加一种叫做MAC的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。

> CBC模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做XOR运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量。

TSL是以SSL为原型开发的协议，有时会统一称该协议为SSL。

## HTTP使用的认证方式 ##
HTTP/1.1使用的认证方式如下所示。

- BASIC认证（基本认证）
- DIGEST（摘要认证）
- SSL客户端认证
- FormBase认证（基于表单认证）

此外，还有Windows统一认证（Keberos认证、NTLM认证）。

### BASIC认证 ###
BASIC认证（基本认证）是从HTTP/1.0就定义的认证方式。是Web服务器与通信客户端之间进行的认证方式。

1. 当请求的资源需要BASIC认证时，服务器会随状态码401Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含认证的方式（BASIC）及Request-URI安全域字符串（realm）。
2. 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器。发送的字符串内容是由用户ID和密码构成，两者中间以冒号（:）连接后，再经过Base64编码处理。
3. 接收到包含首部Authorization请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含Request-URI资源的响应。

BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此它并不常用。

### DIGEST认证 ###
DIGEST认证同样适用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。

1. 请求认证的资源时，服务器会随着状态码401 Authorization Required，返回带WWW-Authenticate首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。首部字段WWW-Authenticate内必须包含realm和nonce这两个字段的信息。客户端就是依靠想服务器回送这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。nonce是一种每次随返回的401响应生成的任意随机字符串。该字符串通常推荐由Base64编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。
2. 接收到401状态码的客户端，返回的响应中包含DIGEST认证必须的首部字段Authorization信息。首部字段Authorization内必须包含username、realm、nonce、uri和response的字段信息。其中，realm和nonce就是之前从服务器接收到的响应中的字段。
3. 接收到包含首部字段Authorization请求的服务器，会确认认证信息的正确性。认证通过后则返回包含Request-URI资源的响应。并且这时会在首部字段Authentication-Info写入一些认证成功的相关信息。

DIGEST认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。

### SSL客户端认证 ###
SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

为达到SSL客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。

1. 接收到需要认证资源的请求，服务器会发送Certificate Request报文，要求客户端提供客户端证书。
2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate报文方式发送给服务器。
3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS加密通信。

所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要甚勤认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。

### 如何保存用户提交的密码 ###
一种安全的保存方法是，先利用给密码加盐（salt）的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。

> salt其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接（前后都可以）生成散列值。

## SPDY ##
开发目标旨在解决HTTP的性能瓶颈，缩短Web页面的加载时间（50%）。

> 使用HTTP协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。

若想在现有Web实现所需的功能，以下这些HTTP标准就会成为瓶颈。

- 一条连接上只可发送一个请求。
- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。
- 请求/响应首部未经压缩就发送。首部信息越多延迟越大。
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
- 可任意选择数据压缩格式。非强制压缩发送。

解决HTTP协议的的问题：

### Ajax ###
Ajax是一种有效利用JavaScript和DOM的操作，以达到局部Web页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。  
Ajax的核心技术是名为XMLHttpRequest的API，通过JavaScript脚本语言的调用就能和服务器进行HTTP通信。

### Comet ###
一旦服务器端游内容更新了，Comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送的功能。内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。

### SPDY的目标 ###
处于持续开发状态中的SPDY协议，正是为了在协议级别消除HTTP所遭遇的瓶颈。

SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。

SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。

使用SPDY后，HTTP协议额外获得以下功能。

- 多路复用流：通过单一的TCP连接，可以无限制处理多个HTTP请求。所有请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。
- 赋予请求优先级：SPDY不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
- 压缩HTTP首部：压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。
- 推送功能：支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
- 服务器提示功能：服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。

## WebSocket ##
WebSocket，即Web浏览器与Web服务器之间全双工通信标准。仍在开发中的WebSocket技术主要是为了解决Ajax和Comet里XMLHttpRequest附带的缺陷所引起的问题。

### WebSocket协议 ###
一旦Web服务器与客户端之间建立起WebSocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML或图片等任意格式的数据。

WebSocket协议的主要特点：

- 推送功能：支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
- 减少通信量：只要建立起WebSocket连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少，而且由于WebSocket的首部信息很小，通信量也相应减少了。

# HTTP/2.0 #
HTTP/2.0的目标是改善用户在使用Web时的速度体验。由于基本上都会先通过HTTP/1.1与TCP连接，子安在我们以下面的这些协议为基础，探讨一下它们的实现方法。

- SPDY
- HTTP Speed + Mobility
- Network-Friendly HTTP Upgrade

HTTP Speed + Mobility由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准。它建立在Google公司提出的SPDY与WebSocket的基础之上。

Network-Friendly HTTP Upgrade主要是在移动端通信时改善HTTP性能的标准。

## WebDAV ##
WebDAV（基于万维网的分布式创作和版本控制）是一个可对Web服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。

## CGI ##
CGI（通用网关接口）是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在CGI作用下，程序会对请求做出相应的动作。使用CGI的程序叫做CGI程序，通常是用Perl、PHP、Ruby和C等编程语言编写而成。

## Servlet ##
Servlet是一种能在服务器上创建动态内容的程序。CGI由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web服务器要承担相当大的负载。而Servlet运行在与Web服务器相同的进程中，因此受到的负载较小。

## 针对Web的攻击技术 ##
- HTTP不具备必要的安全功能

	几乎现今所有的Web网站都会使用会话（session）管理、加密处理等安全性方面的功能，而HTTP协议内并不具备这些功能。
- 在客户端即可篡改请求

	在HTTP请求报文内加载攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这时Web应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。

对Web应用的攻击模式有一下两种

- 主动攻击

	主动攻击是指攻击者通过直接访问Web应用，把攻击代码传入到的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。
- 被动攻击