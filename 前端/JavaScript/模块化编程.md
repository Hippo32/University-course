## 模块化编程 ##
JS中的模块规范（CommonJS，AMD，CMD）

## CommonJS ##
NodeJS是CommonJS规范的实现，webpack也是以CommonJS的形式来书写。

nodejs的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局方法require()，用于加载模块。

CommonJS定义的模块分为：

- 模块引用（require）
- 模块定义（exports）
- 模块标识（module）

require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。

Browserify是目前最常用的CommonJS格式转换的工具。

require是同步的。

> 浏览器的模块，不能采用“同步加载”（synchronous），只能采用“异步加载”（asynchronous）。因此AMD产生了。

CommonJS是主要为了JS在后端的表现制定的，它是不适合前端的，AMD（异步模块定义）出现了，它就主要为前端JS的表现制定规范。

### 关于文件路径 ###
如果没有找到确切的文件，Node将尝试给所需的文件名添加.js后缀再加载，然后再尝试.node。  
.js文件被视为 JavaScript 文本文件，而 .node 文件被视为已编译的插件模块，用dlopen加载。  
模块以`/`开头表示使用文件的绝对路径。例如，require('/home/marco/foo.js')将加载/home/marco/foo.js文件。  
模块以`./`开头表示调用require()时使用相对路径。也就是说，为了保证require('./circle')能找到，circle.js必须和foo.js在同一目录。  
如果不以`/`或`./`开头，该模块可以是一个“核心模块”，也可是一个从node_modules文件夹中加载的模块。从`node_modules`文件夹中加载。  
如果传递给require()有模块标识符是不是原生模块，而且不以`/`、`../`或`./`开头，那么Node从当前模块的父目录+/node_modules这个位置尝试加载。如果还是没有找到，那么它跳到上层目录并依此类推，直到找到模块，或者达到根目录为止。

## AMD ##
AMD推崇**依赖前置**

## CMD ##
CMD推崇**依赖就近**


学习链接：

- [http://www.ruanyifeng.com/blog/2012/10/javascript_module.html](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)

模块化编程的类型：

1. 原始写法：把 不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。

		function m1() {
			//...
		}
	缺点：“污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。
2. 对象写法

	把模块写成一个对象，所有的模块成员都放到这个对象里面。

		var module1 = new Object({
			_count : 0,
			m1 : function () {
				//...
			},
			m2 : function () {
				// ...
			}
		});
	缺点：这样的写法会暴露所有模块成员，内部状态可以被外部改写。
3. 立即执行函数写法

	可以达到不暴露私有成员的目的

		var module1 = (function() {
			var _count = 0;
			var m1 = function() {
				// ...
			};
			var m2 = function() {
				// ...
			};
			return {
				m1 : m1,
				m2 : m2
			};
		})();
4. 放大模式

	如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这是就有必要采用“放大模式”（在立即执行函数中传参，参数为大模块，并将大模块返回）

		var module1 = (function(mod) {
			mod.m3 = function() {
				// ...
			};
			return mod;
		})(module1);
5. 宽放大模式

	与“放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。

	var module1 = (function(mod) {
		//...
		return mod;
	})(window.module1 || {});
6. 输入全局变量

	为了在模块内部调用全局变量，必须显式地将其他变量输入模块。

	var module1 = (function($, YAHOO) {
		// ...
	})(jQuery, YAHOO);

	这样做，除了保证模块的独立性，还使得模块之间的依赖关系变得明显。

## require.js ##
requireJS的诞生解决的问题：

- 实现js文件的异步加载，避免网页失去响应。
- 管理模块之间的依赖性，便于代码的编写和维护。
### require.js的加载 ###
将require.js下载下来，假定把它放在js子目录下

	<script src = "js/require.js" defer async="true"></script>
async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。

加载自己的主模块。

	<script src = "js/require.js" data-main = "js/main"></script>
data-main属性的作用是，指定网页程序的主模块。

### 主模块的写法 ###
主模块依赖于其他模块，使用AMD规范定义的require()函数。

require()函数接受两个参数。第一个参数是数组，表示所依赖的模块；第二个参数是一个回调函数，当前指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。

	// main.js
	require(['moduleA', 'moduleB', 'moduleC'], function(moduleA, moduleB, moduleC) {
		// ...
	});

> require.js要求，每个模块是一个单独的js文件。

### 模块的加载 ###
使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js)的头部。参数就是一个对象。

## AMD模块的写法 ##
AMD是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。

AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：

> require([module], callback);

第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。

目前，主要有两个JS库实现了AMD规范：requireJS和curlJS。

require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。

具体来说，就是模块必须采用特定的define()函数来定义。

定义的模块不依赖其他模块：

	// math.js
	difine(function () {
		var add = function(x, y) {
			return x + y;
		};
		return {
			add : add
		};
	});
定义的模块依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。

	define(['myLib'], function(myLib) {
		function foo() {
			myLib.doSomething();
		}
		return {
			foo : foo
		};
	});

### `require.config()` ###
require.config()就写在主模块（main.js）的头部。require.config()参数是一个对象。

	require.config({
		baseUrl: "js/lib",
		
		paths: {
			"jquery": "jquery.min",
			"underscore": "underscore.min",
			"backbone": "backbone.min"
		}

	});

- baseUrl：如果没有显式指定config及data-main，则默认的baseUrl为包含RequireJS的那个HTML页面的所属目录。如果用了`data-main`	属性，则该路径就变成baseUrl。
	- 如果一个moduleID符合下述规则之一，其ID解析会避开常规的“baseUrl+paths”配置，而是直接将其加载为一个相对于当前HTML文档的脚本：
		- 以`.js`结束
		- 以`/`开始
		- 包含URL协议，如`http:`or`https:`
- paths属性指定各个模块的加载路径
- shim属性，专门用来配置不兼容的模块。shim配置仅设置了代码的依赖关系，想要实际加载shim指定的或涉及的模块，仍然需要一个常规的require/define调用。设置shim本身不会触发代码的加载。具体来说，每个模块要定义
	1. exports值（输出的变量名），表明这个模块外部调用时的名称
	2. deps数组，表明该模块的依赖性
- map；对于给定的模块前缀，使用一个不同的模块ID来加载该模块。
- config：常常需要将配置信息传给一个模块。这些配置往往是application级别的信息，需要一个手段将它们向下传递给模块。
- packages：从CommonJS包（package）中加载模块。
- nodeIdCompat：在放弃加载一个脚本之前等待的秒数。设为0禁用等待超时。默认为7秒。
- waitSeconds：命名一个家在上下文。
- context：指定要加载的一个依赖数组。
- deps：指定要加载的一个依赖数组。
- callback：在deps加载完毕后执行的函数。
- enforceDefine：如果设置为true，则当一个脚本不是通过define()定义且不具备可供检查的shim导出字串值时，就会抛出错误。
- xhtml：如果设置为true，则使用document.createElementNS()去创建script元素。
- urlArgs：RequireJS获取资源时附加在URL后面的额外的query参数。
- scriptType：指定RequireJS将script标签插入document时所用的type=""值。默认为"text/javascript"。

### 加载非规范的模块 ###
没有采用AMD规范编写的模块，如果要加载它们的话，必须先定义它们的特征。

用shim属性，专门用来配置不兼容的模块具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。

### 循环依赖 ###
在模块定义好后用require()方法再获取（记得将require作为依赖注入进来）

### JSONP服务依赖 ###
JSONP是js中服务调用的一种方式。它仅需简单地通过一个script标签发起HTTP GET请求，是实现跨域服务调用一种公认手段。

为了在requirejs中实现JSON服务，需要将callback参数的值指定为“define”。这意味着你可将获取到的JSONP URL的值看成是一个模块定义。

### `requirejs.undef()` ###
重置loader的内部状态以使其忘记之前定义的一个模块。该功能仅在无其他模块持有该模块时的错误处理中。

### about requirejs ###
- require引入的文件（模块），只会解释执行一次，所以引入的模块也可用作全局变量。

## RequireJS和SeaJS ##
SeaJS对模块的态度是懒执行，而RequireJS对模块的态度是预执行。

SeaJS只会在真正需要使用（依赖）模块时才执行该模块。  
SeaJS执行模块的顺序是严格按照模块在代码中出现（require）的顺序。

而RequireJS会先尽早地执行（依赖）模块，相当于所有的require都被提前了，但是模块的执行顺序不一定是require的顺序。

js模块化问题
-
js语言本身不具备模块化的功能，要实现模块化，目前只能靠规范。
<br>目前就三个规范：
<br>**CommonJS**（主要代表NodeJS），主要用于后端，不太适用于前端。
<br>**AMD**（主要代表RequireJS）和**CMD**（代表SeaJS），这两者都是前端的。


学习链接：

- [http://www.ruanyifeng.com/blog/2012/11/require_js.html](http://www.ruanyifeng.com/blog/2012/11/require_js.html)
- [http://www.requirejs.cn/docs/api.html](http://www.requirejs.cn/docs/api.html)
- [http://www.requirejs.cn/home.html](http://www.requirejs.cn/home.html)
- [js模块化编程之彻底弄懂CommonJS和AMD/CMD！](https://www.cnblogs.com/chenguangliang/p/5856701.html)
- [SeaJS与RequireJS最大的区别](https://www.douban.com/note/283566440/)
- [Javascript模块化编程（一）：模块的写法](http://www.ruanyifeng.com/blog/2012/10/javascript_module.html)






